[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "The Interactive Guide to Integer Factorization",
    "section": "",
    "text": "Preface\nThis is a Quarto book.\nTo learn more about Quarto books visit https://quarto.org/docs/books.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "trial-division/index.html",
    "href": "trial-division/index.html",
    "title": "1  Trial Division",
    "section": "",
    "text": "1.1 Test everything!\nThe simplest possible algorithm for factoring an integer n is to just try every possible factor f and look for one that evenly divides n. In other words, the remainder of n when dividing by f (written n % f) should be zero. We start at 2 because every integer is divisible by 1, and we’re looking for a nontrivial factor.\nThis function will always return eventually, once f = n, because every integer is divisible by itself. If no smaller factor was found, n is prime.\nThis algorithm always returns the smallest factor. This factor will always be prime, since if it was a composite number, we already would’ve encountered its factors earlier in the loop.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Trial Division</span>"
    ]
  },
  {
    "objectID": "trial-division/index.html#getting-all-the-factors",
    "href": "trial-division/index.html#getting-all-the-factors",
    "title": "1  Trial Division",
    "section": "1.2 Getting all the factors",
    "text": "1.2 Getting all the factors\nThe above method only returns one prime factor, but if we want all of them, we can just divide n by the first factor, then factor what’s left, until reaching 1:\n\n\n\n\n\n\nThis will work with any factoring method that returns a prime factor. However, in this case this method is wasteful, because it repeatedly checks small factors that were already checked on previous calls. Better is to capture all the factors as we go:\n\n\n\n\n\n\nNote that because factors can be repeated (like 3 here) we must only increment f in the else branch.\nOnce you have all the factors, verifying them by multiplication is easy (note this also works if factors is []):",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Trial Division</span>"
    ]
  },
  {
    "objectID": "trial-division/index.html#square-root-stopping-condition",
    "href": "trial-division/index.html#square-root-stopping-condition",
    "title": "1  Trial Division",
    "section": "1.3 Square root stopping condition",
    "text": "1.3 Square root stopping condition\nThe worst case for trial_division_brute_force() is on a large prime, such as 4256233. In this case, it tries every number less than n before concluding that n is the only factor (O(n) complexity). To fix this problem, we take advantage of this observation:\nFactors always come in pairs. If n is divisible by a, then it is also divisible by n/a, and one of these will always be \\(\\le \\sqrt{n}\\). This is because if both of them were \\(&gt; \\sqrt{n}\\), their product would be &gt; \\(n\\) (and it’s not, it’s exactly \\(n\\)).\nExploiting this gives us a faster trial division algorithm, the most well-known version, with \\(O(\\sqrt{n})\\) complexity:\n\n\n\n\n\n\nIn contexts where f * f can overflow, f &lt;= n/f avoids this, but is more expensive. Both f * f and f &lt;= n/f can be avoided by pre-computing sqrt_n using Python’s efficient math.isqrt(n):\n\n\n\n\n\n\nWe’ll describe how to efficiently implement isqrt(n) yourself later in Section 1.6.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Trial Division</span>"
    ]
  },
  {
    "objectID": "trial-division/index.html#wheel-trial-division",
    "href": "trial-division/index.html#wheel-trial-division",
    "title": "1  Trial Division",
    "section": "1.4 Wheel trial division",
    "text": "1.4 Wheel trial division\nThere is no point in testing even factors &gt; 2, since if 2 doesn’t divide into n, no larger even number will. This reduces runtime by about 2x.\n\n\n\n\n\n\nThis technique can be generalized: suppose we want to skip both all even numbers and all multiples of 3 (other than 2 and 3 themselves). To do this, we break up the factors into groups of 6 starting at 5, the next prime value:\n1 2 3 4 [5 6 7 8 9 10] [11 12 13 14 15 16] [17 18 19 20 21 22] …\nThe numbers in each group can be written as 6k−1, 6k, 6k+1, 6k+2, 6k+3, 6k+4. Three of these (6k, 6k+2, 6k+4) will always be even and can be ignored. Two of them (6k, 6k+3) will always be multiples of 3. That leaves only 6k−1 and 6k+1 that need to be checked:\n1 2 3 4 [5 _ 7 _ _ _ ] [11 __ 13 __ __ __ ] [17 __ 19 __ __ __ ] …\nTo implement this, we start at 5 and alternate between incrementing by 2 and incrementing by 4:\n\n\n\n\n\n\nThe same idea generalizes to even more primes: we could remove all multiples of 2, 3, and 5 using a wheel of size 2 × 3 × 5 = 30, or all multiplies of 2, 3, 5, and 7 using a wheel of size 210. As we increase the wheel size, the number of divisions drops, but the number of residues (and number of if statements) also increases rapidly:\n\n\n\n\n\n\n\n\n\n\nWheel size\nBasis primes\nif statements per loop\nFactors checked (%)\nTheoretical speedup\n\n\n\n\n1\nNone\n1\n100.00%\n1.00x\n\n\n2\n2\n1\n50.00%\n2.00x\n\n\n6\n2, 3\n2\n33.33%\n3.00x\n\n\n30\n2, 3, 5\n8\n26.67%\n3.75x\n\n\n210\n2, 3, 5, 7\n48\n22.86%\n4.37x\n\n\n2,310\n… 11\n480\n20.78%\n4.81x\n\n\n30,030\n… 13\n5,760\n19.18%\n5.21x\n\n\n510,510\n… 17\n92,160\n18.05%\n5.54x\n\n\n9,699,690\n… 19\n1,658,880\n17.10%\n5.85x\n\n\n\nRather than write thousands of lines of code by hand, we can instead use Python metaprogramming techniques, in which you build up a string containing the code and then use exec() on it, to create a version of trial_division_wheel() for each possible wheel size:\n\n\n\n\n\n\nResults show improving performance but with diminishing returns as wheel size increases. If we increase wheel size too much, the code no longer fits in icache and performance degrades drastically. Practical implementations usually pick a fixed wheel size such as 2310, small enough to make this unlikely.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Trial Division</span>"
    ]
  },
  {
    "objectID": "trial-division/index.html#pre-computing-primes-with-the-sieve-of-eratosthenes",
    "href": "trial-division/index.html#pre-computing-primes-with-the-sieve-of-eratosthenes",
    "title": "1  Trial Division",
    "section": "1.5 Pre-computing primes with the Sieve of Eratosthenes",
    "text": "1.5 Pre-computing primes with the Sieve of Eratosthenes\nSuppose rather than just factoring one number, we wanted to factor many numbers. In this case, rather than using a wheel, it’s more efficient to precompute all possible prime factors for all the numbers (up to sqrt of the largest n), and then reuse that list for factoring each one.\nTo precompute the list of primes, we could use trial division to test if each factor is prime, but this is too slow. A faster way is the classical Sieve of Eratosthenes. It begins by assuming all numbers are prime, then removes all multiples of 2, then all multiples of 3, and so on:\n\n\n\n\n\n\nThe range(i*i, n+1, i) skips in steps of i. We start at i*i because j*i for all j &lt; i were already covered by earlier smaller factors. The complexity \\(O(n \\log \\log n)\\) comes from the fact that \\(n/2 + n/3 + n/5 + ...\\) (n times the sum of the reciprocals of the primes) is proportional to \\(n \\log \\log n\\).\nNow we use this list to speed up factoring:\n\n\n\n\n\n\nOn short lists wheel trial division is faster, but on long lists trial_division_many() quickly takes the lead. Many practical implementations will include hard-coded lists of primes to handle factoring numbers up to a certain size (e.g. all 32-bit integers can be factored with a list of just 6542 primes, small enough to fit in a typical L2 cache).\nOne downside of trial_division_many() is that it requires \\(O(\\sqrt{n})\\) space to hold the sieve array in get_primes_up_to(), whereas trial_division_wheel uses constant space. This can be addressed with a segmented sieve, where the sieving range is broken up into pieces of size \\(\\sqrt{\\sqrt{n}} = n^{1/4}\\), and we only keep one piece in memory at a time. Segmenting sieving will be a valuable part of algorithms discussed later in this book.\nTo see how this works, suppose we were naively running trial division on every number in the segment:\n\n\n\n\n\n\nNotice that trial_division_isqrt() only ever checks for factors up to sqrt(max_p). Therefore, every value in the range is either a multiple of a number &lt;= sqrt(max_p), or is prime. So all we have to do is precompute a list of primes at least up to that value, and pass it in:\n\n\n\n\n\n\nIn the example call, only 25 primes are in sieve_primes, so each get_primes_between() will be fast.\nFinally here is our updated trial_division_many():\n\n\n\n\n\n\nIt iterates over the \\(n^{1/4}\\) segments (each of size \\(n^{1/4}\\)) and for each one, tests all primes in that segment against all remaining unfactored integers in the list. The sieve primes used to sieve each segment are also of size \\(n^{1/4}\\). In exchange for a minor slowdown, space use is dramatically reduced, allowing the sieve to complete for large numbers that otherwise would not fit in available memory.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Trial Division</span>"
    ]
  },
  {
    "objectID": "trial-division/index.html#sec-isqrtn",
    "href": "trial-division/index.html#sec-isqrtn",
    "title": "1  Trial Division",
    "section": "1.6 Rolling our own isqrt(n)",
    "text": "1.6 Rolling our own isqrt(n)\nThroughout this section we’ve been depending on math.isqrt(n) to figure out where to stop our loops and how to segment sieving. But how does it work?\nJust like with the square root stopping condition, it relies on the observation that if \\(x &gt; \\sqrt{n}\\), then \\(n/x &lt; \\sqrt{n}\\). Since these two values are on either side of \\(\\sqrt{n}\\), if we average them together, we get a result closer than either one. Then we repeat until the answer is found. This is called Heron’s method.\n\n\n\n\n\n\nNote that the condition y &lt; x checks both for the case where the algorithm converges (x == y) and the case where it oscillates between \\(\\lfloor\\sqrt{n}\\rfloor\\) and \\(\\lceil\\sqrt{n}\\rceil\\).\nHeron’s method is a special case of Newton’s method and can be viewed as finding a root of the function \\(x^2 - n = 0\\). It goes up from the current x guess to the graph, then follows the tangent line back down to the target y value, then repeats this.\n\n\n\n\n\n\n\n\n\nConvergence is quadratic, meaning the number of correct digits doubles at each step. This can be seen better with a very large integer input:\n\n\n\n\n\n\nYou may wonder why we can use integer division in place of regular division. A rigorous analysis of the floor error terms shows that using two integer divisions here is exactly the same as doing the computation in full precision and taking the floor afterwards:\n\\[ \\left\\lfloor\\frac{x + \\lfloor{n/x}\\rfloor}{2}\\right\\rfloor = \\left\\lfloor\\frac{x + (n/x)}{2}\\right\\rfloor \\]\nSince \\(f(x)=x^2-n\\) is convex as shown above, a guess \\(\\geq \\sqrt{n}\\) always yields a next guess \\(\\geq \\sqrt{n}\\). Together, these mean the result is never less than \\(\\lfloor{\\sqrt{n}}\\rfloor\\).",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Trial Division</span>"
    ]
  },
  {
    "objectID": "primality-testing/index.html",
    "href": "primality-testing/index.html",
    "title": "2  Primality Testing",
    "section": "",
    "text": "2.1 Fermat primality test\nIn Chapter 1 we saw that often the worst-case input for trial division was prime numbers: to rule out that these had any nontrivial factors, we had to test every single prime factor between 2 and \\(\\sqrt{n}\\). This is a problem because many numbers that we wish to factor in practice have a form like this, where there are many small factors but one big factor:\n62104940417054684654 = 2 × 17 × 541 × 1223 × 2760727302517\nWith our approach so far, we’d spend most of our runtime just ensuring that the large cofactor 2760727302517 is in fact prime:\nBut what if there were a way to determine if a number is prime quickly without having to test all possible factors? The main idea is: if we can find mathematical properties that prime numbers satisfy but composite numbers don’t, we can use that to differentiate them.\nOur first primality test is based on Fermat’s Little Theorem, which states that:\nFor example, given the prime p = 11 and a = 2, we can compute 211 % 11 = 2048 % 11 = 2. The contrapositive is also true:\nFor example, 215 % 15 = 32768 % 15 = 8 ≠ 2, showing 15 is composite (and 2 is a witness). Note that this doesn’t tell us any factor of 15, only that it has factors.\nWe begin by investigating an for various a and n to see when the property a**n % n == a is satisfied. For efficiency we replace a**n % n by the much faster equivalent pow(a, n, n) ― we will explore in Section 2.3 how pow() works in detail.\nFor primes like 11, 13, and 31, the property is always true. For most composite numbers like 15, 24, and 35, the property is false for at least half of all possible a values. There is no simple way to compute a witness a value such that an % n ≠ a. But because at least half the possible a will work, it’s sufficient to just try random values of a. Each gives us a ≥50% chance of finding a witness, so after trying maybe 30 different values, the chance of failing to find one is &lt; 1/230, incredibly unlikely. This gives us a fast randomized primality test:\nIt can seem strange at first to accept a small chance of failure. However, in the real world hardware failures causing incorrect results are much more likely than 1/230, so this is not an issue in practice.\nUnfortunately, there is a bigger problem with this test: there are certain special composite numbers n called Carmichael numbers (like 561 = 3 × 11 × 17) that always satisfy the Fermat property for all a, just like a prime number, and it will incorrectly return True for these:",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Primality Testing</span>"
    ]
  },
  {
    "objectID": "primality-testing/index.html#sec-fermat-primality-test",
    "href": "primality-testing/index.html#sec-fermat-primality-test",
    "title": "2  Primality Testing",
    "section": "",
    "text": "If p is prime and 1 &lt; a &lt; p, then ap % p = a. (where % is remainder after division)\n\n\n\nIf 1 &lt; a &lt; n and an % n ≠ a, then n is composite. An a satisfying this is called a witness.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2.1.1 Congruence modulo n notation\nBefore proceeding, to make it easier to discuss remainders, we introduce this standard math notation for congruence modulo n:\n\\[ a \\equiv b \\pmod{n} \\]\nThis simply means a % n == b % n. For example:\n\n17 ☰ 5 (mod 4) (because 17 % 4 == 5 % 4 == 1)\n5 ☰ 2 (mod 3) (because 5 % 3 == 2 % 3 == 2)\n15 ☰ 0 (mod 5) (because 15 % 5 == 0 % 5 == 0)\n\nA congruence like this is a lot like an equation: as long as we add, subtract, or multiply both sides by the same number, it will remain true. Dividing both sides by the same number is also allowed, but only under the condition that the divisor and n have no factors in common. Otherwise something like this can happen:\n\n30 ☰ 15 (mod 5) ✅\n6 ☰ 3 (mod 5) ❌ (breaks when dividing both sides by 5)\n10 ☰ 5 (mod 5) ✅ (dividing both sides by 3 is okay, 3 has no factors in common with 5)\n\nUsing this notation, we can rewrite Fermat’s Little Theorem like this:\n\\[ p\\text{ prime}, 1 &lt; a &lt; p \\implies a^p \\equiv a \\pmod p \\]\nIf we divide both sides by a (which shares no factors with p) we also get this common form which we’ll use in the next section:\n\\[ p\\text{ prime}, 1 &lt; a &lt; p \\implies a^{p-1} \\equiv 1 \\pmod p \\]",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Primality Testing</span>"
    ]
  },
  {
    "objectID": "primality-testing/index.html#miller-rabin-to-the-rescue",
    "href": "primality-testing/index.html#miller-rabin-to-the-rescue",
    "title": "2  Primality Testing",
    "section": "2.2 Miller-Rabin to the rescue",
    "text": "2.2 Miller-Rabin to the rescue\nBecause Fermat’s Little Theorem cannot distinguish Carmichael numbers from primes, we need a new theorem that can, so we introduce the Square Roots of Unity Property:\n\nIf p is prime, then for all 2 ≤ x ≤ p−2, x2 ☰ 1 (mod p)\n\nA value x such that x2 ☰ 1 (mod p) is called a square root of unity. The values 1 and p−1 are always square roots of unity (the trivial roots). The above property states that there are no others.\nProof: If x2 ☰ 1 (mod p), that means x2 − 1 = (x − 1)(x + 1) is divisible by p. And if a prime p divides a product, it must divide either one factor or the other. This implies either x ☰ 1 (mod p) or x ☰ −1 (mod p). Either way it’s not between 2 and p−2.\nTo explore this property, we’ll list all the square roots of unity for various n:\n\n\n\n\n\n\nThis property can detect any composite number. However, roots of unity are much sparser than Fermat witnesses, so we can’t just choose a at random and hope to find one. We need a different strategy.\nWe’ll walk through an example with the Carmichael number 561 and the witness a=2. We first do the Fermat test using an-1 ☰ 1 (mod n):\n\n2560 ☰ 1 (mod 561)\n\nAs expected, the Fermat test is inconclusive. But because 560/2 = 280, we can write:\n\n(2280)2 ☰ 1 (mod 561)\n\nThis means 2280 is a square root of unity! Unfortunately, it turns out it’s equivalent to 1, making it a trivial square root of unity:\n\n2280 ☰ 1 (mod 561)\n\nBut because 280/2 = 140, we can repeat this same trick to find that 2140 is a square root of unity. And this one it turns out is nontrivial:\n\n2140 ☰ 67 (mod 561)\n\nSince 672 ☰ 1 (mod 561), this proves 561 is composite. But what if instead of a=2 we used a=101? In this case we would have found:\n\n101560 ☰ 1 (mod 561)\n101280 ☰ 1 (mod 561)\n101140 ☰ 1 (mod 561)\n10170 ☰ 1 (mod 561)\n10135 ☰ 560 (mod 561)\n\nSince 560 = p-1, all of these are trivial square roots of unity. And we can’t continue because 35 is odd. Additionally, once we reach the trivial square root p-1, the next step will no longer be a square root of unity, so we’re stuck. This kind of a that fails to show that n is composite is called a strong liar.\nFortunately, it can be shown that at most 25% of possible a values are strong liars. This means that if we take about 20 values of a at random, the probability of failure will be extremely low:\n\n\n\n\n\n\nThis algorithm works well, but performs more operations than necessary. Miller-Rabin algorithm optimizes it by going in the opposite direction: instead of starting at an-1 and successively dividing the exponent by 2, it instead divides all the 2’s out of the exponent at the beginning and then multiplies them back in one at a time until reaching n-1. For example, with a=2 and p=561:\nn - 1 = 560 = 24 × 35\n((((235)2)2)2)2 = 2560\nIn other words, if we take 235 mod 561, and square it four times mod 561, we will get 2560. If anywhere along the way we encounter 1, that means the previous number in the sequence is a square root of unity:\n\n235 ☰ 263 (mod 561)\n270 ☰ 2632 ☰ 166 (mod 561)\n2140 ☰ 1662 ☰ 140 (mod 561)\n2280 ☰ 1402 ☰ 1 (mod 561)\n2560 ☰ 12 ☰ 1 (mod 561)\n\nBecause 1402 ☰ 1 (mod 561), we have a nontrivial root of unity and 561 is composite. If a=101 on the other hand:\n\n10135 ☰ 560 (mod 561)\n10170 ☰ 5602 ☰ 1 (mod 561)\n101140 ☰ 12 ☰ 1 (mod 561)\n101280 ☰ 12 ☰ 1 (mod 561)\n101560 ☰ 12 ☰ 1 (mod 561)\n\nOnly 1 and n-1 appear, so the test is inconclusive, and we must try a different a.\nOne final example with a=2 and n=453:\nn - 1 = 452 = 22 × 113\n\n2113 ☰ 407 (mod 453)\n2226 ☰ 4072 ☰ 226 (mod 453)\n2452 ☰ 2262 ☰ 4 (mod 453)\n\nBecause we made it to 2n-1 without seeing 1, the number is composite (by Fermat’s Little Theorem). Using this idea, we can now implement Miller-Rabin:\n\n\n\n\n\n\nThe clever thing about Miller-Rabin is that, as we will see below in Section 2.3, all these squaring operations are actually needed to compute an-1 mod n anyway. By simply taking a peek at the intermediate results of this computation, it’s able to solve the Carmichael number problem and provide a reliable test with no additional work.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Primality Testing</span>"
    ]
  },
  {
    "objectID": "primality-testing/index.html#sec-modular-exponentiation",
    "href": "primality-testing/index.html#sec-modular-exponentiation",
    "title": "2  Primality Testing",
    "section": "2.3 Speeding up exponentiation mod n",
    "text": "2.3 Speeding up exponentiation mod n\nWhen running Miller-Rabin on a prime like 179424893 with witness a=2, we need to compute 2**44856223 % 179424893. The final result 117471984 is manageable, but the intermediate result 2**44856223 has over 13 million digits, making this very slow. We’ve been using Python’s built-in pow() which can do this quickly, but how does it work?\nLet’s start with a simpler example. Suppose we want 21000000 mod 13. By splitting up 1000000 into 10 × 10 × 10 × 10 × 10 × 10, we can split up the computation like this:\n21000000 = (((((210)10)10)10)10)10\nBy taking % 13 after each step, all of our intermediate results remain small, and the computation is dramatically faster:\n\n\n\n\n\n\nWith a more complex power like 2547, we can break it down like this:\n547 = (((5 × 10) + 4) × 10) + 7\n2547 = ((25)10 × 24)10 × 27\nThis suggests a general solution. We extract the decimal digits of the power k and then alternate between exponentiating by 10 and multiplying by a**digit for each digit:\n\n\n\n\n\n\nThis works well, but improvements can be made by switching from base 10 to another base. Which base is optimal depends on the precise input parameters, but binary has some big advantages for large inputs:\n\nExtracting the digits from k with bit operations is fast.\nExponentiation by 2 can be replaced with a single multiplication.\nMost importantly, the size of intermediate results never exceeds n2.\n\n\n\n\n\n\n\nOn small inputs, the large digit count of the binary version creates substantial overhead, but on large inputs, its smaller intermediate results allow it to even approach the performance of pow().\nNotice how both power_mod_binary() and is_prime_miller_rabin() use squaring to double an exponent. This technique will be common in many algorithms.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Primality Testing</span>"
    ]
  },
  {
    "objectID": "primality-testing/index.html#primality-certificates",
    "href": "primality-testing/index.html#primality-certificates",
    "title": "2  Primality Testing",
    "section": "2.4 Primality certificates",
    "text": "2.4 Primality certificates\nIn practice, the chance of Miller-Rabin failing is so tiny as to be irrelevant. But in certain special applications, it’s still useful to be able to prove with certainty that a number is prime. Although there are deterministic algorithms to determine if a number is prime with certainty (the AKS algorithm), these are impractical for real-world use.\nInstead, we’ll pursue a different approach where we construct a primality certificate, a set of information that anyone can use to quickly verify that a given number is prime. Verifying that the certificate is valid is easy and fast, but finding it is difficult and requires some advanced techniques and heuristics.\n\n2.4.1 Pratt certificates\nThe simplest kind of primality certificate is the Pratt certificate. It’s based on Lucas’s theorem, which states that if the following two conditions are true for some witness a, then n is prime:\n\nan−1 ☰ 1 (mod n)\nFor every prime factor q of n, we have \\(a^{(n-1)/q} \\not\\equiv 1 \\pmod n\\).\n\nFor example, take n = 15485863. This number is prime, but to prove it using the theorem above, I have to tell you what a is, and tell you the prime factorization of n-1:\n15485863: a = 6, 15485862 = 2 × 3 × 72 × 52673\nGiven this information, checking it is simple:\n\n\n\n\n\n\nThere is however a problem with this verifier: it trusts that the prime factors of n−1 that you gave it are actually prime. This makes it possible to trick it into accepting a composite number by giving it a composite factor:\n\n\n\n\n\n\nThe verifier could test if the factors are prime, but if they’re large, this could be expensive. Instead, we provide Pratt certificates for the prime factors as well. We continue this recursively until we get a number small enough to check manually:\n\n\n\n\n\n\nUsing this scheme, it’s easy to quickly and reliably verify any number is prime if I just give you a valid Pratt certificate, even if the certificate itself was very expensive to produce. But there’s a catch: for some large p where p - 1 cannot be completely factored in practice, we cannot produce a certificate at all. We’ll need new techniques to address this.\n\n\n2.4.2 The group \\(\\mathbb{Z}_p^*\\)\n\n\n2.4.3 Order of an element and Lagrange’s theorem\nTake a look at the powers of 3 mod 7:\n3, 9, 27, 81, … (mod 7)\n3, 2, 6, 4, 5, 1, 3, 2, 6, 4, 5, 1, 3, …\nThey form a cycle that repeats every 6 powers. This cycle length 6 is called the order of 3 in the group \\(\\mathbb{Z}_7^*\\). This helps explain why Fermat’s Little Theorem is true: if we repeat every n−1 powers, and we started at a power of 1, we must come back around to where we started at the power n.\nIf we do the same thing with other values of a, it still repeats every 6 powers, but for some elements it may also repeat even faster than that:\n\n\n\n\na\na1\na2\na3\na4\na5\na6\na7\n\n\n\n\n2\n2\n4\n1\n2\n4\n1\n2\n\n\n3\n3\n2\n6\n4\n5\n1\n3\n\n\n4\n4\n2\n1\n4\n2\n1\n4\n\n\n5\n5\n4\n6\n2\n3\n1\n5\n\n\n6\n6\n1\n6\n1\n6\n1\n6\n\n\n\n\nSome elements have order 6, some order 3, and some order 2. All of them have order that is a factor of 6. In general, in the integers mod p for any prime p, all 1 ≤ a ≤ n-1 will have an order dividing p-1.\nIn group theory terms, this is a special case of Lagrange’s Theorem, which says that any subgroup of a group will have a size that divides the size of the full group. Here the full group is \\(\\mathbb{Z}_p^*\\), the numbers 1 through p-1 with the operation of multiplication mod p, which has size p-1.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Primality Testing</span>"
    ]
  }
]
[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "The Interactive Guide to Integer Factorization",
    "section": "",
    "text": "Preface\nThis is a Quarto book.\nTo learn more about Quarto books visit https://quarto.org/docs/books.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "trial-division/index.html",
    "href": "trial-division/index.html",
    "title": "1  Trial Division",
    "section": "",
    "text": "1.1 Test everything!\nThe simplest possible algorithm for factoring an integer n is to just try every possible factor f and look for one that evenly divides n. In other words, the remainder of n when dividing by f (written n % f) should be zero. We start at 2 because every integer is divisible by 1, and we’re looking for a nontrivial factor.\nThis function will always return eventually, once f = n, because every integer is divisible by itself. If no smaller factor was found, n is prime.\nThis algorithm always returns the smallest factor. This factor will always be prime, since if it was a composite number, we already would’ve encountered its factors earlier in the loop.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Trial Division</span>"
    ]
  },
  {
    "objectID": "trial-division/index.html#getting-all-the-factors",
    "href": "trial-division/index.html#getting-all-the-factors",
    "title": "1  Trial Division",
    "section": "1.2 Getting all the factors",
    "text": "1.2 Getting all the factors\nThe above method only returns one prime factor, but if we want all of them, we can just divide n by the first factor, then factor what’s left, until reaching 1:\n\n\n\n\n\n\nThis will work with any factoring method that returns a prime factor. However, in this case this method is wasteful, because it repeatedly checks small factors that were already checked on previous calls. Better is to capture all the factors as we go:\n\n\n\n\n\n\nNote that because factors can be repeated (like 3 here) we must only increment f in the else branch.\nOnce you have all the factors, verifying them by multiplication is easy (note this also works if factors is []):",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Trial Division</span>"
    ]
  },
  {
    "objectID": "trial-division/index.html#square-root-stopping-condition",
    "href": "trial-division/index.html#square-root-stopping-condition",
    "title": "1  Trial Division",
    "section": "1.3 Square root stopping condition",
    "text": "1.3 Square root stopping condition\nThe worst case for trial_division_brute_force() is on a large prime, such as 4256233. In this case, it tries every number less than n before concluding that n is the only factor (O(n) complexity). To fix this problem, we take advantage of this observation:\nFactors always come in pairs. If n is divisible by a, then it is also divisible by n/a, and one of these will always be \\(\\le \\sqrt{n}\\). This is because if both of them were \\(&gt; \\sqrt{n}\\), their product would be &gt; \\(n\\) (and it’s not, it’s exactly \\(n\\)).\nExploiting this gives us a faster trial division algorithm, the most well-known version, with \\(O(\\sqrt{n})\\) complexity:\n\n\n\n\n\n\nIn contexts where f * f can overflow, f &lt;= n/f avoids this, but is more expensive. Both f * f and f &lt;= n/f can be avoided by pre-computing sqrt_n using Python’s efficient math.isqrt(n):\n\n\n\n\n\n\nWe’ll describe how to efficiently implement isqrt(n) yourself later in Section 1.6.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Trial Division</span>"
    ]
  },
  {
    "objectID": "trial-division/index.html#wheel-trial-division",
    "href": "trial-division/index.html#wheel-trial-division",
    "title": "1  Trial Division",
    "section": "1.4 Wheel trial division",
    "text": "1.4 Wheel trial division\nThere is no point in testing even factors &gt; 2, since if 2 doesn’t divide into n, no larger even number will. This reduces runtime by about 2x.\n\n\n\n\n\n\nThis technique can be generalized: suppose we want to skip both all even numbers and all multiples of 3 (other than 2 and 3 themselves). To do this, we break up the factors into groups of 6 starting at 5, the next prime value:\n1 2 3 4 [5 6 7 8 9 10] [11 12 13 14 15 16] [17 18 19 20 21 22] …\nThe numbers in each group can be written as 6k−1, 6k, 6k+1, 6k+2, 6k+3, 6k+4. Three of these (6k, 6k+2, 6k+4) will always be even and can be ignored. Two of them (6k, 6k+3) will always be multiples of 3. That leaves only 6k−1 and 6k+1 that need to be checked:\n1 2 3 4 [5 _ 7 _ _ _ ] [11 __ 13 __ __ __ ] [17 __ 19 __ __ __ ] …\nTo implement this, we start at 5 and alternate between incrementing by 2 and incrementing by 4:\n\n\n\n\n\n\nThe same idea generalizes to even more primes: we could remove all multiples of 2, 3, and 5 using a wheel of size 2 × 3 × 5 = 30, or all multiplies of 2, 3, 5, and 7 using a wheel of size 210. As we increase the wheel size, the number of divisions drops, but the number of residues (and number of if statements) also increases rapidly:\n\n\n\n\n\n\n\n\n\n\nWheel size\nBasis primes\nif statements per loop\nFactors checked (%)\nTheoretical speedup\n\n\n\n\n1\nNone\n1\n100.00%\n1.00x\n\n\n2\n2\n1\n50.00%\n2.00x\n\n\n6\n2, 3\n2\n33.33%\n3.00x\n\n\n30\n2, 3, 5\n8\n26.67%\n3.75x\n\n\n210\n2, 3, 5, 7\n48\n22.86%\n4.37x\n\n\n2,310\n… 11\n480\n20.78%\n4.81x\n\n\n30,030\n… 13\n5,760\n19.18%\n5.21x\n\n\n510,510\n… 17\n92,160\n18.05%\n5.54x\n\n\n9,699,690\n… 19\n1,658,880\n17.10%\n5.85x\n\n\n\nRather than write thousands of lines of code by hand, we can instead use Python metaprogramming techniques, in which you build up a string containing the code and then use exec() on it, to create a version of trial_division_wheel() for each possible wheel size:\n\n\n\n\n\n\nResults show improving performance but with diminishing returns as wheel size increases. If we increase wheel size too much, the code no longer fits in icache and performance degrades drastically. Practical implementations usually pick a fixed wheel size such as 2310, small enough to make this unlikely.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Trial Division</span>"
    ]
  },
  {
    "objectID": "trial-division/index.html#pre-computing-primes-with-the-sieve-of-eratosthenes",
    "href": "trial-division/index.html#pre-computing-primes-with-the-sieve-of-eratosthenes",
    "title": "1  Trial Division",
    "section": "1.5 Pre-computing primes with the Sieve of Eratosthenes",
    "text": "1.5 Pre-computing primes with the Sieve of Eratosthenes\nSuppose rather than just factoring one number, we wanted to factor many numbers. In this case, rather than using a wheel, it’s more efficient to precompute all possible prime factors for all the numbers (up to sqrt of the largest n), and then reuse that list for factoring each one.\nTo precompute the list of primes, we could use trial division to test if each factor is prime, but this is too slow. A faster way is the classical Sieve of Eratosthenes. It begins by assuming all numbers are prime, then removes all multiples of 2, then all multiples of 3, and so on:\n\n\n\n\n\n\nThe range(i*i, n+1, i) skips in steps of i. We start at i*i because j*i for all j &lt; i were already covered by earlier smaller factors. The complexity \\(O(n \\log \\log n)\\) comes from the fact that \\(n/2 + n/3 + n/5 + ...\\) (n times the sum of the reciprocals of the primes) is proportional to \\(n \\log \\log n\\).\nNow we use this list to speed up factoring:\n\n\n\n\n\n\nOn short lists wheel trial division is faster, but on long lists trial_division_many() quickly takes the lead. Many practical implementations will include hard-coded lists of primes to handle factoring numbers up to a certain size (e.g. all 32-bit integers can be factored with a list of just 6542 primes, small enough to fit in a typical L2 cache).\nOne downside of trial_division_many() is that it requires \\(O(\\sqrt{n})\\) space to hold the sieve array in get_primes_up_to(), whereas trial_division_wheel uses constant space. This can be addressed with a segmented sieve, where the sieving range is broken up into pieces of size \\(\\sqrt{\\sqrt{n}} = n^{1/4}\\), and we only keep one piece in memory at a time. Segmenting sieving will be a valuable part of algorithms discussed later in this book.\nTo see how this works, suppose we were naively running trial division on every number in the segment:\n\n\n\n\n\n\nNotice that trial_division_isqrt() only ever checks for factors up to sqrt(max_p). Therefore, every value in the range is either a multiple of a number &lt;= sqrt(max_p), or is prime. So all we have to do is precompute a list of primes at least up to that value, and pass it in:\n\n\n\n\n\n\nIn the example call, only 25 primes are in sieve_primes, so each get_primes_between() will be fast.\nFinally here is our updated trial_division_many():\n\n\n\n\n\n\nIt iterates over the \\(n^{1/4}\\) segments (each of size \\(n^{1/4}\\)) and for each one, tests all primes in that segment against all remaining unfactored integers in the list. The sieve primes used to sieve each segment are also of size \\(n^{1/4}\\). In exchange for a minor slowdown, space use is dramatically reduced, allowing the sieve to complete for large numbers that otherwise would not fit in available memory.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Trial Division</span>"
    ]
  },
  {
    "objectID": "trial-division/index.html#sec-isqrtn",
    "href": "trial-division/index.html#sec-isqrtn",
    "title": "1  Trial Division",
    "section": "1.6 Rolling our own isqrt(n)",
    "text": "1.6 Rolling our own isqrt(n)",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Trial Division</span>"
    ]
  }
]